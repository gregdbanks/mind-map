# How Node Position Persistence Works

This document explains how node positions are saved and maintained in the mind map application.

## Overview

Yes, node positions are persisted through the API to the database. Here's the complete flow:

## 1. User Drags a Node

When you drag a node in the UI:

```typescript
// In Node.tsx
<Group
  x={node.positionX}
  y={node.positionY}
  draggable
  onDragEnd={(e) => {
    const newX = e.target.x()
    const newY = e.target.y()
    onPositionChange(node.id, newX, newY)
  }}
>
```

## 2. State Update (Optimistic)

The MindMapContext immediately updates local state for instant feedback:

```typescript
// In MindMapContext.tsx
updateNodePosition: (nodeId: string, x: number, y: number) => {
  // Optimistic update - immediate UI response
  dispatch({ 
    type: 'UPDATE_NODE', 
    payload: { id: nodeId, positionX: x, positionY: y } 
  })
  
  // Then persist to backend
  api.updateNode(nodeId, { positionX: x, positionY: y })
}
```

## 3. API Call

The position change is sent to the backend:

```typescript
// PUT /api/nodes/:id
{
  "positionX": 450,
  "positionY": 320
}
```

## 4. Database Update

The backend updates the Node entity in PostgreSQL:

```sql
-- Generated by TypeORM
UPDATE nodes 
SET "positionX" = 450, 
    "positionY" = 320,
    "updatedAt" = NOW()
WHERE id = 'node-uuid';
```

## 5. Persistence Confirmation

The complete Node entity definition includes position:

```typescript
// backend/src/entities/Node.ts
@Entity('nodes')
export class Node {
  @Column('float')
  positionX: number

  @Column('float') 
  positionY: number
  
  // These ensure positions are saved
}
```

## Data Flow Diagram

```
User Drags Node
      ↓
Canvas onDragEnd Event
      ↓
MindMapContext.updateNodePosition()
      ↓
├─→ Local State Update (Instant UI)
│
└─→ API Call (Background)
         ↓
    Backend Validation
         ↓
    Database Update
         ↓
    Success Response
```

## Key Features

### 1. **Optimistic Updates**
- Position updates immediately in UI
- No lag while waiting for server
- Rollback on error (if implemented)

### 2. **Caching Strategy**
- Positions cached locally
- Reduces API calls
- Survives page refreshes (via localStorage)

### 3. **Batch Updates**
Available for moving multiple nodes:
```typescript
// POST /api/mindmaps/:id/nodes/batch-update
{
  "updates": [
    { "id": "node1", "positionX": 100, "positionY": 200 },
    { "id": "node2", "positionX": 300, "positionY": 400 }
  ]
}
```

## When Positions Load

1. **Initial Load**: When opening a mind map, all node positions come from the database
2. **Real-time Updates**: Each drag saves the new position
3. **Refresh**: Positions reload from the last saved state

## Performance Considerations

### Current Implementation
- Every drag end triggers an API call
- Each call updates one node
- Works well for typical usage

### Future Optimizations
1. **Debouncing**: Wait 500ms after drag ends before saving
2. **Batching**: Collect multiple moves, save together
3. **Differential Sync**: Only send position deltas
4. **WebSocket**: Real-time position sync for collaboration

## Canvas State Persistence

Besides individual nodes, the canvas view state is also persisted:

```typescript
// CanvasState entity
{
  zoom: 1.5,      // Zoom level
  panX: -200,     // Pan offset X
  panY: -100      // Pan offset Y
}
```

This ensures users return to the same view when reopening a mind map.

## Error Handling

If position save fails:
1. User sees error notification
2. Position remains in local state
3. Retry on next action
4. Defensive caching prevents data loss

## Testing Position Persistence

```bash
# Create a node
curl -X POST http://localhost:3001/api/mindmaps/:id/nodes \
  -d '{"text": "Test", "positionX": 100, "positionY": 100}'

# Move it
curl -X PUT http://localhost:3001/api/nodes/:nodeId \
  -d '{"positionX": 200, "positionY": 200}'

# Verify it saved
curl http://localhost:3001/api/nodes/:nodeId
# Should show new position
```

## Summary

Every position change is automatically saved to the database, ensuring your mind map layout is preserved exactly as you arranged it. The combination of optimistic updates and background persistence provides a smooth, reliable user experience.